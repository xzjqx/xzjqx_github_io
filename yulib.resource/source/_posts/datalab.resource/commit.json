{"compress":true,"commitItems":[["5d55bc10-6133-4da5-b123-9d823570a332",1523536897615,"---\nlayout: post\ntitle: Lorem ipsum\ncategories: \n  - consectetur\n  - malesuada\ntags:\n  - semper\n  - fermentum\n---\n\n![Nulla euismod, vitae aliquet orci eleifend.]($appres/images/night.jpg)\n\n## Lorem ipsum\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus eu tempor dolor. Nulla hendrerit convallis purus et elementum. **Suspendisse** non magna vel **justo tincidunt** finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl.\n\n## Ac semper purus\n\nPraesent accumsan ipsum sit amet varius tempor. Duis sollicitudin in magna vitae convallis. Vestibulum nec fermentum justo, sed vestibulum tortor. Sed hendrerit ligula in imperdiet tempus. Duis a lorem diam. Duis hendrerit ligula lacus, vitae aliquet orci imperdiet eleifend. Mauris accumsan, quam molestie ultrices placerat, sapien turpis mattis purus, eget euismod arcu est nec sapien.\n\n> \"Ipsum quia dolor sit amet, consectetur, adipisci velit...\"\n\nInteger tincidunt nunc quis tortor tristique, ut egestas metus volutpat. In sit amet dolor leo. dictum in odio eu vulputate. Nullam a ornare elit, a sollicitudin augue.\n\nDonec neque velit, gravida eu tempor nec, sagittis ut lectus. Quisque laoreet dignissim facilisis. Cras vel rutrum odio, in mollis elit. _Maecenas_ malesuada est sit amet eleifend vulputate. Quisque in ultrices erat. Aenean mollis nibh et ligula _accumsan_ semper vitae sed nisi. Ut pulvinar aliquam nulla, id cursus augue tincidunt sed.\n\n## Arcu est nec sapien\n\nMaecenas id feugiat urna, sed volutpat purus. Vivamus porttitor consequat vulputate.\n\nNullam at erat faucibus mi interdum sodales. Quisque venenatis sagittis justo a volutpat. Nam libero enim, auctor iaculis velit tincidunt, blandit blandit enim. \n\n![In quis enim hendrerit nulla porttitor posuere]($appres/images/flower.jpg)\n\nA ultricies dui dictum sit amet. Vivamus velit eros, feugiat non est vel, sodales sagittis turpis. Suspendisse potenti. ~~Nulla facilisi~~ Ut feugiat, velit sit amet congue maximus, dui erat semper ex, ut sodales quam justo in odio. Integer fermentum sem quis dui ultrices scelerisque. \n\nFusce et metus libero. Phasellus turpis odio, scelerisque eu purus ac, semper varius lacus. Praesent ullamcorper blandit sem, eu feugiat leo. Nulla hendrerit convallis purus et elementum. Suspendisse non magna vel justo tincidunt finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl.\n",[[1523536844142,["xzjqx@LAPTOP-GDGGKCGC",[[-1,89,"semper"],[1,95,"C"]],[89,95],[89,90]]],[1523536844992,["xzjqx@LAPTOP-GDGGKCGC",[[1,90,"+"]],[89,90],[89,91]]],[1523536845153,["xzjqx@LAPTOP-GDGGKCGC",[[1,91,"+"]],[89,91],[89,92]]],[1523536847866,["xzjqx@LAPTOP-GDGGKCGC",[[-1,90,"++"]],[92,92],[90,90]]],[1523536851057,["xzjqx@LAPTOP-GDGGKCGC",[[1,90,"/C++"]],[90,90],[94,94]]],[1523536859875,["xzjqx@LAPTOP-GDGGKCGC",[[-1,95,"  - fermentum\n"]],[94,108],[94,94]]],[1523536863283,["xzjqx@LAPTOP-GDGGKCGC",[[-1,48,"\n  - consectetur\n  - malesuada"],[1,78,"j"]],[48,78],[48,49]]],[1523536863435,["xzjqx@LAPTOP-GDGGKCGC",[[1,49,"i"]],[48,49],[48,50]]],[1523536863617,["xzjqx@LAPTOP-GDGGKCGC",[[1,50,"'s"]],[48,50],[48,52]]],[1523536863636,["xzjqx@LAPTOP-GDGGKCGC",[[1,52,"u"]],[48,52],[48,53]]],[1523536863751,["xzjqx@LAPTOP-GDGGKCGC",[[1,53,"a"]],[48,53],[48,54]]],[1523536863824,["xzjqx@LAPTOP-GDGGKCGC",[[1,54,"n"]],[48,54],[48,55]]],[1523536864003,["xzjqx@LAPTOP-GDGGKCGC",[[1,55,"'j"]],[48,55],[48,57]]],[1523536864118,["xzjqx@LAPTOP-GDGGKCGC",[[1,57,"i"]],[48,57],[48,58]]],[1523536864600,["xzjqx@LAPTOP-GDGGKCGC",[[-1,48,"ji'suan'ji"],[1,58,"计算机"]],[48,58],[48,51]]],[1523536865777,["xzjqx@LAPTOP-GDGGKCGC",[[1,51,"系统"]],[51,51],[53,53]]],[1523536880336,["xzjqx@LAPTOP-GDGGKCGC",[[1,17,"\n"]],[16,16],[17,17]]],[1523536880558,["xzjqx@LAPTOP-GDGGKCGC",[[1,17,"date: 2015-11-16 11:11:48"]],[17,17],[42,42]]]]],["bc726ece-62bb-4f94-9aa9-9caf2ac0c42a",1523587461980,"---\nlayout: post\ndate: 2015-11-16 11:11:48\ntitle: Lorem ipsum\ncategories: 计算机系统\ntags:\n  - C/C++\n---\n\n![Nulla euismod, vitae aliquet orci eleifend.]($appres/images/night.jpg)\n\n## Lorem ipsum\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus eu tempor dolor. Nulla hendrerit convallis purus et elementum. **Suspendisse** non magna vel **justo tincidunt** finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl.\n\n## Ac semper purus\n\nPraesent accumsan ipsum sit amet varius tempor. Duis sollicitudin in magna vitae convallis. Vestibulum nec fermentum justo, sed vestibulum tortor. Sed hendrerit ligula in imperdiet tempus. Duis a lorem diam. Duis hendrerit ligula lacus, vitae aliquet orci imperdiet eleifend. Mauris accumsan, quam molestie ultrices placerat, sapien turpis mattis purus, eget euismod arcu est nec sapien.\n\n> \"Ipsum quia dolor sit amet, consectetur, adipisci velit...\"\n\nInteger tincidunt nunc quis tortor tristique, ut egestas metus volutpat. In sit amet dolor leo. dictum in odio eu vulputate. Nullam a ornare elit, a sollicitudin augue.\n\nDonec neque velit, gravida eu tempor nec, sagittis ut lectus. Quisque laoreet dignissim facilisis. Cras vel rutrum odio, in mollis elit. _Maecenas_ malesuada est sit amet eleifend vulputate. Quisque in ultrices erat. Aenean mollis nibh et ligula _accumsan_ semper vitae sed nisi. Ut pulvinar aliquam nulla, id cursus augue tincidunt sed.\n\n## Arcu est nec sapien\n\nMaecenas id feugiat urna, sed volutpat purus. Vivamus porttitor consequat vulputate.\n\nNullam at erat faucibus mi interdum sodales. Quisque venenatis sagittis justo a volutpat. Nam libero enim, auctor iaculis velit tincidunt, blandit blandit enim. \n\n![In quis enim hendrerit nulla porttitor posuere]($appres/images/flower.jpg)\n\nA ultricies dui dictum sit amet. Vivamus velit eros, feugiat non est vel, sodales sagittis turpis. Suspendisse potenti. ~~Nulla facilisi~~ Ut feugiat, velit sit amet congue maximus, dui erat semper ex, ut sodales quam justo in odio. Integer fermentum sem quis dui ultrices scelerisque. \n\nFusce et metus libero. Phasellus turpis odio, scelerisque eu purus ac, semper varius lacus. Praesent ullamcorper blandit sem, eu feugiat leo. Nulla hendrerit convallis purus et elementum. Suspendisse non magna vel justo tincidunt finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl.\n",[[1523587427430,["xzjqx@LAPTOP-GDGGKCGC",[[-1,50,"Lorem ipsum"],[1,61,"深入理解计算机系统（CSAPP）实验二 Datalab"]],[50,61],[77,77]]],[1523587431828,["xzjqx@LAPTOP-GDGGKCGC",[[-1,26,"5"]],[27,27],[26,26]]],[1523587431920,["xzjqx@LAPTOP-GDGGKCGC",[[1,26,"8"]],[26,26],[27,27]]],[1523587453855,["xzjqx@LAPTOP-GDGGKCGC",[[-1,28,"11"]],[30,30],[28,28]]],[1523587454559,["xzjqx@LAPTOP-GDGGKCGC",[[1,28,"03"]],[28,28],[30,30]]],[1523587457414,["xzjqx@LAPTOP-GDGGKCGC",[[-1,29,"3"]],[30,30],[29,29]]],[1523587457501,["xzjqx@LAPTOP-GDGGKCGC",[[1,29,"4"]],[29,29],[30,30]]],[1523587459950,["xzjqx@LAPTOP-GDGGKCGC",[[-1,31,"16"]],[33,33],[31,31]]],[1523587460901,["xzjqx@LAPTOP-GDGGKCGC",[[1,31,"13"]],[31,31],[33,33]]],[1523587466992,["xzjqx@LAPTOP-GDGGKCGC",[[-1,35,"1"]],[36,36],[35,35]]],[1523587467365,["xzjqx@LAPTOP-GDGGKCGC",[[1,35,"0"]],[35,35],[36,36]]],[1523587468890,["xzjqx@LAPTOP-GDGGKCGC",[[-1,37,"11"]],[39,39],[37,37]]],[1523587469293,["xzjqx@LAPTOP-GDGGKCGC",[[1,37,"44"]],[37,37],[39,39]]],[1523587503762,["xzjqx@LAPTOP-GDGGKCGC",[[-1,117,"![Nulla euismod, vitae aliquet orci eleifend.]($appres/images/night.jpg)\n"]],[116,189],[116,116]]],[1523587504167,["xzjqx@LAPTOP-GDGGKCGC",[[-1,117,"\n"]],[116,116],[115,115]]],[1523587505366,["xzjqx@LAPTOP-GDGGKCGC",[[-1,116,"\n"]],[116,116],[115,115]]],[1523587946450,["xzjqx@LAPTOP-GDGGKCGC",[[-1,119,"Lorem ipsum"],[1,130,"bitAnd - x&y using only ~ and |"]],[119,130],[150,150]]],[1523587957367,["xzjqx@LAPTOP-GDGGKCGC",[[-1,152,"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus eu tempor dolor. Nulla hendrerit convallis purus et elementum. **Suspendisse** non magna vel **justo tincidunt** finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl."],[1,401,"目标：不使用&运算符计算按位与运算\n\n方法：运用德·摩根定律：非(P 且 Q) = (非 P) 或 (非 Q)\n\n代码：\n\n_int_  bitAnd(_int_ x, _int_ y) {\n\n  return  ~((~x) | (~y));\n\n}"]],[402,402],[277,277]]],[1523588073090,["xzjqx@LAPTOP-GDGGKCGC",[[-1,170,"\n"]],[170,170],[169,169]]],[1523588076602,["xzjqx@LAPTOP-GDGGKCGC",[[-1,207,"\n"]],[207,207],[206,206]]],[1523588085447,["xzjqx@LAPTOP-GDGGKCGC",[[-1,216,"_"]],[217,217],[216,216]]],[1523588087124,["xzjqx@LAPTOP-GDGGKCGC",[[-1,212,"_i"]],[214,214],[212,212]]],[1523588089262,["xzjqx@LAPTOP-GDGGKCGC",[[1,212,"i"]],[212,212],[213,213]]],[1523588091262,["xzjqx@LAPTOP-GDGGKCGC",[[-1,224,"_"]],[225,225],[224,224]]],[1523588675789,["xzjqx@LAPTOP-GDGGKCGC",[[-1,212,"int  bitAnd(int_ x, _int_ y) {\n\n  return  ~((~x) | (~y));\n\n}"]],[212,272],[212,212]]],[1523588676347,["xzjqx@LAPTOP-GDGGKCGC",[[-1,213,"\n"]],[212,212],[211,211]]],[1523588695194,["xzjqx@LAPTOP-GDGGKCGC",[[-1,207,"代码："]],[207,210],[207,207]]],[1523588707555,["xzjqx@LAPTOP-GDGGKCGC",[[1,208,"```\nint bitAnd(int x, int y) {\n  return ~((~x) | (~y));\n}\n```\n\n"]],[207,207],[270,270]]],[1523588709243,["xzjqx@LAPTOP-GDGGKCGC",[[-1,272,"\n"]],[270,270],[269,269]]],[1523588710649,["xzjqx@LAPTOP-GDGGKCGC",[[-1,271,"\n"]],[271,271],[270,270]]],[1523588710963,["xzjqx@LAPTOP-GDGGKCGC",[[-1,270,"\n"]],[270,270],[269,269]]],[1523588711348,["xzjqx@LAPTOP-GDGGKCGC",[[-1,268,"`"]],[269,269],[268,268]]],[1523588713367,["xzjqx@LAPTOP-GDGGKCGC",[[1,268,"`"]],[268,268],[269,269]]],[1523588743468,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1275,"Maecenas id feugiat urna, sed volutpat purus. Vivamus porttitor consequat vulputate.\n\nNullam at erat faucibus mi interdum sodales. Quisque venenatis sagittis justo a volutpat. Nam libero enim, auctor iaculis velit tincidunt, blandit blandit enim. \n\n![In quis enim hendrerit nulla porttitor posuere]($appres/images/flower.jpg)\n\nA ultricies dui dictum sit amet. Vivamus velit eros, feugiat non est vel, sodales sagittis turpis. Suspendisse potenti. ~~Nulla facilisi~~ Ut feugiat, velit sit amet congue maximus, dui erat semper ex, ut sodales quam justo in odio. Integer fermentum sem quis dui ultrices scelerisque. \n\nFusce et metus libero. Phasellus turpis odio, scelerisque eu purus ac, semper varius lacus. Praesent ullamcorper blandit sem, eu feugiat leo. Nulla hendrerit convallis purus et elementum. Suspendisse non magna vel justo tincidunt finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl.\n"]],[1274,2189],[1274,1274]]],[1523588748431,["xzjqx@LAPTOP-GDGGKCGC",[[-1,290,"Praesent accumsan ipsum sit amet varius tempor. Duis sollicitudin in magna vitae convallis. Vestibulum nec fermentum justo, sed vestibulum tortor. Sed hendrerit ligula in imperdiet tempus. Duis a lorem diam. Duis hendrerit ligula lacus, vitae aliquet orci imperdiet eleifend. Mauris accumsan, quam molestie ultrices placerat, sapien turpis mattis purus, eget euismod arcu est nec sapien.\n\n> \"Ipsum quia dolor sit amet, consectetur, adipisci velit...\"\n\nInteger tincidunt nunc quis tortor tristique, ut egestas metus volutpat. In sit amet dolor leo. dictum in odio eu vulputate. Nullam a ornare elit, a sollicitudin augue.\n\nDonec neque velit, gravida eu tempor nec, sagittis ut lectus. Quisque laoreet dignissim facilisis. Cras vel rutrum odio, in mollis elit. _Maecenas_ malesuada est sit amet eleifend vulputate. Quisque in ultrices erat. Aenean mollis nibh et ligula _accumsan_ semper vitae sed nisi. Ut pulvinar aliquam nulla, id cursus augue tincidunt sed."]],[290,1249],[290,290]]],[1523588939425,["xzjqx@LAPTOP-GDGGKCGC",[[-1,273,"Ac semper purus"],[1,288,"getByte - Extract byte n from word x"]],[273,288],[309,309]]],[1523589288150,["xzjqx@LAPTOP-GDGGKCGC",[[1,311,"目标：提取一个字中的特定一个字节\n\n方法：将字向右移位到最低字节，再与0xff按位与得到目标字节"]],[311,311],[359,359]]],[1523589290008,["xzjqx@LAPTOP-GDGGKCGC",[[-1,328,"\n"]],[328,328],[327,327]]],[1523589295132,["xzjqx@LAPTOP-GDGGKCGC",[[-1,207,"\n"]],[207,207],[206,206]]],[1523589369091,["xzjqx@LAPTOP-GDGGKCGC",[[1,359,"```\nint getByte(int x, int n) {\n  return (x >> (n << 3)) & 0xff;\n}\n\n```\n\n"]],[358,358],[431,431]]],[1523589371945,["xzjqx@LAPTOP-GDGGKCGC",[[-1,426,"\n"]],[426,426],[425,425]]],[1523589376292,["xzjqx@LAPTOP-GDGGKCGC",[[-1,430,"\n"]],[430,430],[429,429]]],[1523590114289,["xzjqx@LAPTOP-GDGGKCGC",[[-1,433,"Arcu est nec sapien"],[1,452,"logicalShift - shift x to the right by n, using a logical shift"]],[433,452],[496,496]]],[1523590173899,["xzjqx@LAPTOP-GDGGKCGC",[[1,497,"目标：将x逻辑右移n位\n\n方法：>>操作符是算术右移，故使用>>右移后，将高n位置零即可"]],[497,497],[541,541]]],[1523590175586,["xzjqx@LAPTOP-GDGGKCGC",[[1,497,"\n"]],[496,496],[497,497]]],[1523590176467,["xzjqx@LAPTOP-GDGGKCGC",[[-1,510,"\n"]],[510,510],[509,509]]],[1523590179355,["xzjqx@LAPTOP-GDGGKCGC",[[1,542,"\n"]],[541,541],[542,542]]],[1523590188523,["xzjqx@LAPTOP-GDGGKCGC",[[1,543,"```\nint logicalShift(int x, int n) {\n  int mask = ~(1 << 31);   // mask = 0x7fffffff\n  mask = mask >> n;\n  mask = mask << 1;\n  mask = mask + 1;         // mask高n位为0，低位为1\n  return (x >> n) & mask;\n}\n```\n\n"]],[542,542],[745,745]]],[1523590193659,["xzjqx@LAPTOP-GDGGKCGC",[[-1,745,"\n"],[1,746,"## "]],[745,745],[748,748]]],[1523590382917,["xzjqx@LAPTOP-GDGGKCGC",[[1,748,"bitCount - returns count of number of 1's in word"]],[748,748],[797,797]]],[1523590384122,["xzjqx@LAPTOP-GDGGKCGC",[[1,797,"\n\n"]],[797,797],[798,798]]],[1523590389385,["xzjqx@LAPTOP-GDGGKCGC",[[1,799,"\n"]],[798,798],[799,799]]],[1523590389680,["xzjqx@LAPTOP-GDGGKCGC",[[1,799,"目标：计算x中有多少位1\n\n方法：将x分为四个字节，分别计算1的数量（共计算八次），最后将结果分为四个字节计算总和即为最终答案"]],[799,799],[862,862]]],[1523590391550,["xzjqx@LAPTOP-GDGGKCGC",[[-1,812,"\n"]],[812,812],[811,811]]],[1523590393477,["xzjqx@LAPTOP-GDGGKCGC",[[1,862,"\n"]],[861,861],[862,862]]],[1523590468410,["xzjqx@LAPTOP-GDGGKCGC",[[1,863,"```\nint bitCount(int x) {\n  int result = 0;\n  int mask = 1 | (1 << 8);\n  mask = mask | (mask << 16);         // mask = 0x01010101\n  result = result + (x & mask);\n  result = result + ((x>>1) & mask);\n  result = result + ((x>>2) & mask);\n  result = result + ((x>>3) & mask);\n  result = result + ((x>>4) & mask);\n  result = result + ((x>>5) & mask);\n  result = result + ((x>>6) & mask);\n  result = result + ((x>>7) & mask);  // result的每一个字节为x在这个字节上1的数量\n  return (result & 0xff) + ((result>>8) &0xff) + ((result>>16) &0xff) + ((result>>24) &0xff);\n}\n```\n\n"]],[862,862],[1413,1413]]],[1523592991822,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1413,"\n"],[1,1414,"## "]],[1413,1413],[1416,1416]]],[1523593000180,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1414,"# "]],[1416,1416],[1414,1414]]],[1523593000702,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1413,"#"],[1,1414,"\n"]],[1414,1414],[1413,1413]]],[1523593011522,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1413,"\n"],[1,1414,"## bang - Compute !x without using !"]],[1413,1413],[1449,1449]]],[1523593012803,["xzjqx@LAPTOP-GDGGKCGC",[[1,1449,"\n\n"]],[1449,1449],[1450,1450]]],[1523593033633,["xzjqx@LAPTOP-GDGGKCGC",[[1,1451,"\n"]],[1450,1450],[1451,1451]]],[1523593033885,["xzjqx@LAPTOP-GDGGKCGC",[[1,1451,"目标：不使用!运算符计算!x\n\n方法：将x与-x进行或运算，若x为0，最高位为0，反之最高位为1；将结果右移31位得到0xffffffff或0x00000000，加上1即为最终结果"]],[1451,1451],[1541,1541]]],[1523593035489,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1466,"\n"]],[1466,1466],[1465,1465]]],[1523593037042,["xzjqx@LAPTOP-GDGGKCGC",[[1,1541,"\n"]],[1540,1540],[1541,1541]]],[1523593044451,["xzjqx@LAPTOP-GDGGKCGC",[[1,1542,"```\nint bang(int x) {\n  int tmp = ~x + 1;       // tmp = -x;\n  tmp = x | tmp;          // tmp = x | -x; 若x=0，最高位为0，反之最高位为1\n  return (tmp >> 31) + 1;\n}\n```\n\n"]],[1541,1541],[1697,1697]]],[1523593054181,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1697,"\n"],[1,1698,"## #### tmin - return minimum two's complement integer\n\n目标：求得二进制整数的最小值\n\n方法：1左移31位即可"]],[1697,1697],[1780,1780]]],[1523593056820,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1768,"\n"]],[1768,1768],[1767,1767]]],[1523593065400,["xzjqx@LAPTOP-GDGGKCGC",[[1,1779,"\n\n```\nint tmin(void) {\n  return 1<<31;\n}\n```\n\n"]],[1779,1779],[1824,1824]]],[1523593068074,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1824,"\n"],[1,1825,"## "]],[1824,1824],[1827,1827]]],[1523594591607,["xzjqx@LAPTOP-GDGGKCGC",[[1,1827,"#### fitsBits - return 1 if x can be represented as an n-bit, two's complement integer.\n\n目标：如果x能被n位二进制补码表示，则返回1\n\n方法：如果x能被n位二进制表示，则x前(32-n)位都是相同的"]],[1827,1827],[1971,1971]]],[1523594595953,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1827,"#### "]],[1832,1832],[1827,1827]]],[1523594598001,["xzjqx@LAPTOP-GDGGKCGC",[[-1,1934,"\n"]],[1934,1934],[1933,1933]]],[1523594607746,["xzjqx@LAPTOP-GDGGKCGC",[[1,1965,"\n\n```\nint fitsBits(int x, int n) {\n  return !((x << (33 + ~n) >> (33 + ~n)) ^ x);\n}\n```\n\n"]],[1965,1965],[2053,2053]]],[1523594617352,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2053,"\n"],[1,2054,"## #### divpwr2 - Compute x/(2^n), for 0 <= n <= 30\n\n目标：计算 x/(2^n)\n\n方法：对于正数，直接右移n位即可；对于负数，需要加上偏置量bias后右移"]],[2053,2053],[2157,2157]]],[1523594619794,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2057,"###"]],[2060,2060],[2057,2057]]],[1523594621278,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2055," #"]],[2057,2057],[2055,2055]]],[1523594622419,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2115,"\n"]],[2115,2115],[2114,2114]]],[1523594632456,["xzjqx@LAPTOP-GDGGKCGC",[[1,2151,"\n\n```\nint divpwr2(int x, int n) {\n  int sign = x >> 31;        // 若x为负数，sign = 0xffffffff\n  int mask = (1 << n) + ~0; // mask为0x0000ffff形式\n  int bias = sign & mask;   // 若x为负数，bias有值\n  return (x + bias) >> n;\n}\n```\n\n"]],[2151,2151],[2366,2366]]],[1523594641131,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2366,"\n"],[1,2367,"## negate - return -x"]],[2366,2366],[2387,2387]]],[1523594649147,["xzjqx@LAPTOP-GDGGKCGC",[[1,2387,"\n\n目标：求相反数\n\n方法：补码取相反数，包含符号位一起取反再加一"]],[2387,2387],[2419,2419]]],[1523594650777,["xzjqx@LAPTOP-GDGGKCGC",[[1,2388,"\n"]],[2387,2387],[2388,2388]]],[1523594652214,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2397,"\n"]],[2397,2397],[2396,2396]]],[1523594658960,["xzjqx@LAPTOP-GDGGKCGC",[[1,2420,"\n"]],[2419,2419],[2420,2420]]],[1523594663057,["xzjqx@LAPTOP-GDGGKCGC",[[1,2421,"```\nint negate(int x) {\n  return ~x + 1;\n}\n```\n\n"]],[2420,2420],[2468,2468]]],[1523594672395,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2468,"\n"],[1,2469,"## #### isPositive - return 1 if x > 0, return 0 otherwise\n\n目标：判断x是否为正数\n\n方法：直接通过x的符号位可以分出负数，再对x两次取非可以判断是否为0"]],[2468,2468],[2575,2575]]],[1523594674630,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2471,"#### "]],[2476,2476],[2471,2471]]],[1523594675979,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2535,"\n"]],[2535,2535],[2534,2534]]],[1523594677211,["xzjqx@LAPTOP-GDGGKCGC",[[1,2569,"\n\n"]],[2569,2569],[2570,2570]]],[1523594739857,[null,[[-1,2389,"\n"],[1,2420,"\n"]],[2389,2389],[2421,2421]]],[1523594739857,[null,[[1,2389,"\n"],[-1,2419,"\n"]],[2421,2421],[2389,2389]]],[1523594703397,["xzjqx@LAPTOP-GDGGKCGC",[[1,2571,"```\nint isPositive(int x) {\n  return (!((x >> 31) & 1) & !!x);\n}\n```\n\n#### isLessOrEqual - if x <= y then return 1, else return 0\n\n目标：判断是否x <= y\n\n方法：当x与y异号时，只要x为负数，x<=y；当x与y同号时，利用isPositive函数的方法判断y-x是否为正数或0即可\n\n代码：\n\n_int_  isLessOrEqual(_int_ x, _int_ y) {\n\n  _int_ signx = (x >>  31) &  1;\n\n  _int_ signy = (y >>  31) &  1;\n\n  _int_ sign = (signx ^ signy) & signx;// 异号\n\n  _int_ tmp = y +  ~x +  1;\n\n tmp = (!((tmp >>  31) &  1)) & (!(signx ^ signy)); // 同号\n\n  return (sign | tmp);\n\n}\n\n#### 1.12 ilog2 - return floor(log base 2 of x), where x > 0\n\n目标：求floor(log2x)\n\n方法：通过二分法找到x中最高位1的位数，这个位数就是要求出的结果\n\n代码：\n\n_int_  ilog2(_int_ x) {\n\n  _int_ bits=0;\n\n bits = (!!(x>>16))<<4;\n\n bits = bits + ((!!(x>>(bits+8)))<<3);\n\n bits = bits + ((!!(x>>(bits+4)))<<2);\n\n bits = bits + ((!!(x>>(bits+2)))<<1);\n\n bits = bits + (!!(x>>(bits+1)));\n\n bits = bits + (!!bits)+(~0)+(!(1^x));\n\n  return bits;\n\n}\n\n#### 1.13 float_neg - Return bit-level equivalent of expression -f for floating point argument f\n\n目标：将浮点数uf取反\n\n方法：若uf不是NaN，直接将符号位取反，否则返回uf\n\n代码：\n\n_unsigned_  float_neg(_unsigned_ uf) {\n\n  _unsigned_ result;\n\n  _unsigned_ tmp;\n\n result=uf ^  0x80000000; //将符号位改反\n\n tmp=uf & (0x7fffffff);\n\n  if(tmp >  0x7f800000) //此时是NaN\n\n result = uf;\n\n  return result;\n\n}\n\n#### 1.14 float_i2f - Return bit-level equivalent of expression (float) x\n\n目标：返回整数x的对应的浮点数的二进制表示形式\n\n方法：这是一个求阶码与尾数的过程\n\n  由于整数x一定是规格化数，故按照规格化标准转化；\n\n因为规格化的值尾数定义为M=1+f，故将x左移到最高一位1超出32位时，剩下的即为尾数；\n\n  阶码是32减去上述转移的位数，故阶码字段值为127+32-shift\n\n代码：\n\n_unsigned_  float_i2f(_int_ x) {\n\n  _unsigned_ sign =  0; // 符号位\n\n  _unsigned_  exp; // 阶码\n\n  _unsigned_ frac; // 尾数\n\n  _unsigned_ shift =  0, tmp, rounding =  0;\n\n  if(x ==  0) return x; // 为0时直接返回0\n\n  if(x <  0) {\n\n x =  -x;\n\n sign =  1;\n\n } // x取绝对值，记录符号位\n\n frac = x;\n\n  while(1) {\n\n tmp = frac;\n\n shift ++;\n\n frac <<=  1;\n\n  if(tmp &  0x80000000) break;\n\n }\n\n  exp  = (159  - shift) <<  23; // 计算阶码\n\n  if((frac &  0x1ff) >  0x100) rounding =  1; // 向上舍入\n\n  else  if((frac &  0x3ff) ==  0x300) rounding =  1; // 向上舍入\n\n frac = (frac >>  9) + rounding; // 计算尾数\n\n  return (sign <<  31) +  exp  + frac;\n\n}\n\n#### 1.15 float_twice - Return bit-level equivalent of expression 2*f for\n\n目标：返回浮点uf的两倍（以unsigned的形式）\n\n方法：对于非规格化的数，uf的两倍等价于尾数左移一位，即小数字段左移移位；对于规格化的数，uf的两倍等价于阶码加一，即阶码字段加一\n\n代码：\n\n_unsigned_  float_twice(_unsigned_ uf) {\n\n  _unsigned_ f = uf;\n\n  if ((f &  0x7F800000) ==  0) { // 非规格化的\n\n f = ((f &  0x007FFFFF) <<  1) | (0x80000000  & f);\n\n }\n\n  else  if ((f &  0x7F800000) !=  0x7F800000) { // 规格化的\n\n f = f +  0x00800000;\n\n }\n\n  return f;\n\n}"]],[2570,2570],[5091,5091]]],[1523594705943,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2641,"###"]],[2644,2644],[2641,2641]]],[1523594726154,["xzjqx@LAPTOP-GDGGKCGC",[[1,2641,"#"]],[2641,2641],[2642,2642]]],[1523594728538,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2713,"\n"]],[2713,2713],[2712,2712]]],[1523594730139,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2781,"\n"]],[2781,2781],[2780,2780]]],[1523594730863,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2777,"代码："]],[2780,2780],[2777,2777]]],[1523594731055,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2777,"\n"]],[2777,2777],[2776,2776]]],[1523594736267,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2777,"_int_  isLessOrEqual(_int_ x, _int_ y) {\n\n  _int_ signx = (x >>  31) &  1;\n\n  _int_ signy = (y >>  31) &  1;\n\n  _int_ sign = (signx ^ signy) & signx;// 异号\n\n  _int_ tmp = y +  ~x +  1;\n\n tmp = (!((tmp >>  31) &  1)) & (!(signx ^ signy)); // 同号\n\n  return (sign | tmp);\n\n}\n"]],[2776,3046],[2776,2776]]],[1523594738733,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2777,"\n"]],[2776,2776],[2775,2775]]],[1523594799883,[null,[[-1,2389,"\n"],[1,2420,"\n"],[-1,2639,"\n"],[1,4813,"\n"]],[2389,2389],[4814,4814]]],[1523594799883,[null,[[1,2389,"\n"],[-1,2419,"\n"],[1,2639,"\n"],[-1,4812,"\n"]],[4814,4814],[2389,2389]]],[1523594755581,["xzjqx@LAPTOP-GDGGKCGC",[[1,2776,"_int_  isLessOrEqual(_int_ x, _int_ y) {\n\n  _int_ signx = (x >>  31) &  1;\n\n  _int_ signy = (y >>  31) &  1;\n\n  _int_ sign = (signx ^ signy) & signx;// 异号\n\n  _int_ tmp = y +  ~x +  1;\n\n tmp = (!((tmp >>  31) &  1)) & (!(signx ^ signy)); // 同号\n\n  return (sign | tmp);\n\n}"]],[2776,2776],[3045,3045]]],[1523594757309,["xzjqx@LAPTOP-GDGGKCGC",[[-1,2776,"_int_  isLessOrEqual(_int_ x, _int_ y) {\n\n  _int_ signx = (x >>  31) &  1;\n\n  _int_ signy = (y >>  31) &  1;\n\n  _int_ sign = (signx ^ signy) & signx;// 异号\n\n  _int_ tmp = y +  ~x +  1;\n\n tmp = (!((tmp >>  31) &  1)) & (!(signx ^ signy)); // 同号\n\n  return (sign | tmp);\n\n}"]],[3045,3045],[2776,2776]]],[1523594761402,["xzjqx@LAPTOP-GDGGKCGC",[[1,2777,"```\nint isLessOrEqual(int x, int y) {\n  int signx = (x >> 31) & 1;\n  int signy = (y >> 31) & 1;\n  int sign = (signx ^ signy) & signx;               \t // 异号\n  int tmp = y + ~x + 1;\n  tmp = (!((tmp >> 31) & 1)) & (!(signx ^ signy));  // 同号\n  return (sign | tmp);\n}\n```\n\n"]],[2776,2776],[3044,3044]]],[1523594763194,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3044,"\n"]],[3044,3044],[3043,3043]]],[1523594764967,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3123,"\n"]],[3123,3123],[3122,3122]]],[1523594768814,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3157,"代码：\n\n_int_  ilog2(_int_ x) {\n\n  _int_ bits=0;\n\n bits = (!!(x>>16))<<4;\n\n bits = bits + ((!!(x>>(bits+8)))<<3);\n\n bits = bits + ((!!(x>>(bits+4)))<<2);\n\n bits = bits + ((!!(x>>(bits+2)))<<1);\n\n bits = bits + (!!(x>>(bits+1)));\n\n bits = bits + (!!bits)+(~0)+(!(1^x));\n\n  return bits;\n\n}\n\n"]],[3156,3442],[3156,3156]]],[1523594782354,["xzjqx@LAPTOP-GDGGKCGC",[[1,3157,"```\nint ilog2(int x) {\n  int bits=0;\n  bits = (!!(x>>16))<<4;\n  bits = bits + ((!!(x>>(bits+8)))<<3);\n  bits = bits + ((!!(x>>(bits+4)))<<2);\n  bits = bits + ((!!(x>>(bits+2)))<<1);\n  bits = bits + (!!(x>>(bits+1)));\n  bits = bits + (!!bits)+(~0)+(!(1^x));\n  return bits;\n}\n```\n\n"]],[3156,3156],[3435,3435]]],[1523594784982,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3435,"\n"]],[3435,3435],[3434,3434]]],[1523594797383,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3545,"\n"]],[3545,3545],[3544,3544]]],[1523594859876,[null,[[-1,2389,"\n"],[1,2421,"\n"],[-1,2640,"\n"],[1,2777,"\n"],[-1,3044,"\n"],[1,3157,"\n"],[1,3431,""],[-1,3434,"\n"],[1,5070,"\n"]],[2389,2389],[5071,5071]]],[1523594859876,[null,[[1,2389,"\n"],[-1,2420,"\n"],[1,2640,"\n"],[-1,2776,"\n"],[1,3044,"\n"],[-1,3156,"\n"],[-1,3431,""],[1,3434,"\n"],[-1,5069,"\n"]],[5071,5071],[2389,2389]]],[1523594801226,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3574,"代码：\n\n_unsigned_  float_neg(_unsigned_ uf) {\n\n  _unsigned_ result;\n\n  _unsigned_ tmp;\n\n result=uf ^  0x80000000; //将符号位改反\n\n tmp=uf & (0x7fffffff);\n\n  if(tmp >  0x7f800000) //此时是NaN\n\n result = uf;\n\n  return result;\n\n}\n\n"]],[3573,3790],[3573,3573]]],[1523594806603,["xzjqx@LAPTOP-GDGGKCGC",[[1,3574,"```\nunsigned float_neg(unsigned uf) {\n  unsigned result;\n  unsigned tmp;\n  result=uf ^ 0x80000000; //将符号位改反\n  tmp=uf & (0x7fffffff);\n  if(tmp > 0x7f800000)    //此时是NaN\n    result = uf;\n  return result;\n}\n```\n\n"]],[3573,3573],[3782,3782]]],[1523594808171,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3782,"\n"]],[3782,3782],[3781,3781]]],[1523594811332,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3881,"\n"]],[3881,3881],[3880,3880]]],[1523594812883,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3784,"##"]],[3786,3786],[3784,3784]]],[1523594815003,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3437,"##"]],[3439,3439],[3437,3437]]],[1523594817376,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3437," 1.13"]],[3442,3442],[3437,3437]]],[1523594820781,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3046,"## 1.12 "]],[3054,3054],[3046,3046]]],[1523594821594,["xzjqx@LAPTOP-GDGGKCGC",[[1,3046," "]],[3046,3046],[3047,3047]]],[1523594826926,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3770," 1.14"]],[3775,3775],[3770,3770]]],[1523594832441,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3877,"\n"]],[3877,3877],[3876,3876]]],[1523594844143,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3877,"  "]],[3879,3879],[3877,3877]]],[1523594845680,["xzjqx@LAPTOP-GDGGKCGC",[[1,3877,"\t\t"]],[3877,3877],[3879,3879]]],[1523594852152,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3904,"\n"]],[3904,3904],[3903,3903]]],[1523594854659,["xzjqx@LAPTOP-GDGGKCGC",[[1,3904,"\t\t"]],[3904,3904],[3906,3906]]],[1523594856750,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3951,"\n"]],[3951,3951],[3950,3950]]],[1523594858428,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3951,"  "]],[3953,3953],[3951,3951]]],[1523594858802,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3950,"\n"]],[3951,3951],[3950,3950]]],[1523594866516,[null,[[-1,2389,"\n"],[1,2421,"\n"],[-1,2640,"\n"],[1,2777,"\n"],[-1,3044,"\n# "],[1,3047,"##"],[1,3150,"\n"],[-1,3428,"\n#3"],[1,3431,"##"],[1,3560,"\n"],[-1,3768,"\n#4"],[1,3771,"##"],[1,3877,"\n"],[-1,3879," "],[1,3904,"\n"],[-1,3906,"\n"],[-1,3950," "],[1,3951,"；"],[-1,5035,""],[1,5035,"\n"]],[2389,2389],[5036,5036]]],[1523594866516,[null,[[1,2389,"\n"],[-1,2420,"\n"],[1,2640,"\n"],[-1,2776,"\n"],[1,3044,"\n# "],[-1,3044,"##"],[-1,3149,"\n"],[1,3428,"\n#3"],[-1,3428,"##"],[-1,3559,"\n"],[1,3768,"\n#4"],[-1,3768,"##"],[-1,3876,"\n"],[1,3879," "],[-1,3903,"\n"],[1,3906,"\n"],[1,3949," "],[-1,3949,"；"],[1,5034,""],[-1,5034,"\n"]],[5036,5036],[2389,2389]]],[1523594861086,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3904,"\t\t"]],[3906,3906],[3904,3904]]],[1523594861368,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3903,"\n"]],[3904,3904],[3903,3903]]],[1523594863732,["xzjqx@LAPTOP-GDGGKCGC",[[1,3879,"\n"]],[3879,3879],[3880,3880]]],[1523594866570,[null,[[-1,2389,"\n"],[1,2421,"\n"],[-1,2640,"\n"],[1,2777,"\n"],[-1,3044,"\n# "],[1,3047,"##"],[1,3150,"\n"],[-1,3428,"\n#3"],[1,3431,"##"],[1,3560,"\n"],[-1,3768,"\n#4"],[1,3771,"##"],[1,3877,"\n"],[-1,3880," "],[-1,3904,"\n"],[1,3905,"；"],[-1,3948," "],[1,3949,"；"],[-1,5033,""],[1,5033,"\n"]],[2389,2389],[5034,5034]]],[1523594866570,[null,[[1,2389,"\n"],[-1,2420,"\n"],[1,2640,"\n"],[-1,2776,"\n"],[1,3044,"\n# "],[-1,3044,"##"],[-1,3149,"\n"],[1,3428,"\n#3"],[-1,3428,"##"],[-1,3559,"\n"],[1,3768,"\n#4"],[-1,3768,"##"],[-1,3876,"\n"],[1,3880," "],[1,3903,"\n"],[-1,3903,"；"],[1,3947," "],[-1,3947,"；"],[1,5032,""],[-1,5032,"\n"]],[5034,5034],[2389,2389]]],[1523594861086,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3904,"\t\t"]],[3906,3906],[3904,3904]]],[1523594861368,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3903,"\n"]],[3904,3904],[3903,3903]]],[1523594863732,["xzjqx@LAPTOP-GDGGKCGC",[[1,3879,"\n"]],[3879,3879],[3880,3880]]]]],["f19da772-5620-4691-b05b-2d2e3c6bd923",1523594930123,"---\nlayout: post\ndate: 2018-04-13 10:44:48\ntitle: 深入理解计算机系统（CSAPP）实验二 Datalab\ncategories: 计算机系统\ntags:\n  - C/C++\n---\n## bitAnd - x&y using only ~ and |\n\n目标：不使用&运算符计算按位与运算\n方法：运用德·摩根定律：非(P 且 Q) = (非 P) 或 (非 Q)\n```\nint bitAnd(int x, int y) {\n  return ~((~x) | (~y));\n}\n```\n## getByte - Extract byte n from word x\n\n目标：提取一个字中的特定一个字节\n方法：将字向右移位到最低字节，再与0xff按位与得到目标字节\n\n```\nint getByte(int x, int n) {\n  return (x >> (n << 3)) & 0xff;\n}\n```\n## logicalShift - shift x to the right by n, using a logical shift\n\n目标：将x逻辑右移n位\n方法：>>操作符是算术右移，故使用>>右移后，将高n位置零即可\n\n```\nint logicalShift(int x, int n) {\n  int mask = ~(1 << 31);   // mask = 0x7fffffff\n  mask = mask >> n;\n  mask = mask << 1;\n  mask = mask + 1;         // mask高n位为0，低位为1\n  return (x >> n) & mask;\n}\n```\n## bitCount - returns count of number of 1's in word\n\n目标：计算x中有多少位1\n方法：将x分为四个字节，分别计算1的数量（共计算八次），最后将结果分为四个字节计算总和即为最终答案\n\n```\nint bitCount(int x) {\n  int result = 0;\n  int mask = 1 | (1 << 8);\n  mask = mask | (mask << 16);         // mask = 0x01010101\n  result = result + (x & mask);\n  result = result + ((x>>1) & mask);\n  result = result + ((x>>2) & mask);\n  result = result + ((x>>3) & mask);\n  result = result + ((x>>4) & mask);\n  result = result + ((x>>5) & mask);\n  result = result + ((x>>6) & mask);\n  result = result + ((x>>7) & mask);  // result的每一个字节为x在这个字节上1的数量\n  return (result & 0xff) + ((result>>8) &0xff) + ((result>>16) &0xff) + ((result>>24) &0xff);\n}\n```\n## bang - Compute !x without using !\n\n目标：不使用!运算符计算!x\n方法：将x与-x进行或运算，若x为0，最高位为0，反之最高位为1；将结果右移31位得到0xffffffff或0x00000000，加上1即为最终结果\n\n```\nint bang(int x) {\n  int tmp = ~x + 1;       // tmp = -x;\n  tmp = x | tmp;          // tmp = x | -x; 若x=0，最高位为0，反之最高位为1\n  return (tmp >> 31) + 1;\n}\n```\n## #### tmin - return minimum two's complement integer\n\n目标：求得二进制整数的最小值\n方法：1左移31位即可\n\n```\nint tmin(void) {\n  return 1<<31;\n}\n```\n## fitsBits - return 1 if x can be represented as an n-bit, two's complement integer.\n\n目标：如果x能被n位二进制补码表示，则返回1\n方法：如果x能被n位二进制表示，则x前(32-n)位都是相同的\n\n```\nint fitsBits(int x, int n) {\n  return !((x << (33 + ~n) >> (33 + ~n)) ^ x);\n}\n```\n## divpwr2 - Compute x/(2^n), for 0 <= n <= 30\n\n目标：计算 x/(2^n)\n方法：对于正数，直接右移n位即可；对于负数，需要加上偏置量bias后右移\n\n```\nint divpwr2(int x, int n) {\n  int sign = x >> 31;        // 若x为负数，sign = 0xffffffff\n  int mask = (1 << n) + ~0; // mask为0x0000ffff形式\n  int bias = sign & mask;   // 若x为负数，bias有值\n  return (x + bias) >> n;\n}\n```\n## negate - return -x\n\n目标：求相反数\n方法：补码取相反数，包含符号位一起取反再加一\n\n```\nint negate(int x) {\n  return ~x + 1;\n}\n```\n## isPositive - return 1 if x > 0, return 0 otherwise\n\n目标：判断x是否为正数\n方法：直接通过x的符号位可以分出负数，再对x两次取非可以判断是否为0\n\n```\nint isPositive(int x) {\n  return (!((x >> 31) & 1) & !!x);\n}\n```\n## isLessOrEqual - if x <= y then return 1, else return 0\n\n目标：判断是否x <= y\n方法：当x与y异号时，只要x为负数，x<=y；当x与y同号时，利用isPositive函数的方法判断y-x是否为正数或0即可\n\n```\nint isLessOrEqual(int x, int y) {\n  int signx = (x >> 31) & 1;\n  int signy = (y >> 31) & 1;\n  int sign = (signx ^ signy) & signx;               \t // 异号\n  int tmp = y + ~x + 1;\n  tmp = (!((tmp >> 31) & 1)) & (!(signx ^ signy));  // 同号\n  return (sign | tmp);\n}\n```\n## ilog2 - return floor(log base 2 of x), where x > 0\n\n目标：求floor(log2x)\n方法：通过二分法找到x中最高位1的位数，这个位数就是要求出的结果\n\n```\nint ilog2(int x) {\n  int bits=0;\n  bits = (!!(x>>16))<<4;\n  bits = bits + ((!!(x>>(bits+8)))<<3);\n  bits = bits + ((!!(x>>(bits+4)))<<2);\n  bits = bits + ((!!(x>>(bits+2)))<<1);\n  bits = bits + (!!(x>>(bits+1)));\n  bits = bits + (!!bits)+(~0)+(!(1^x));\n  return bits;\n}\n```\n## float_neg - Return bit-level equivalent of expression -f for floating point argument f\n\n目标：将浮点数uf取反\n方法：若uf不是NaN，直接将符号位取反，否则返回uf\n\n```\nunsigned float_neg(unsigned uf) {\n  unsigned result;\n  unsigned tmp;\n  result=uf ^ 0x80000000; //将符号位改反\n  tmp=uf & (0x7fffffff);\n  if(tmp > 0x7f800000)    //此时是NaN\n    result = uf;\n  return result;\n}\n```\n## float_i2f - Return bit-level equivalent of expression (float) x\n\n目标：返回整数x的对应的浮点数的二进制表示形式\n方法：这是一个求阶码与尾数的过程\n\t\t\n由于整数x一定是规格化数，故按照规格化标准转化；因为规格化的值尾数定义为M=1+f，故将x左移到最高一位1超出32位时，剩下的即为尾数；阶码是32减去上述转移的位数，故阶码字段值为127+32-shift\n\n代码：\n\n_unsigned_  float_i2f(_int_ x) {\n\n  _unsigned_ sign =  0; // 符号位\n\n  _unsigned_  exp; // 阶码\n\n  _unsigned_ frac; // 尾数\n\n  _unsigned_ shift =  0, tmp, rounding =  0;\n\n  if(x ==  0) return x; // 为0时直接返回0\n\n  if(x <  0) {\n\n x =  -x;\n\n sign =  1;\n\n } // x取绝对值，记录符号位\n\n frac = x;\n\n  while(1) {\n\n tmp = frac;\n\n shift ++;\n\n frac <<=  1;\n\n  if(tmp &  0x80000000) break;\n\n }\n\n  exp  = (159  - shift) <<  23; // 计算阶码\n\n  if((frac &  0x1ff) >  0x100) rounding =  1; // 向上舍入\n\n  else  if((frac &  0x3ff) ==  0x300) rounding =  1; // 向上舍入\n\n frac = (frac >>  9) + rounding; // 计算尾数\n\n  return (sign <<  31) +  exp  + frac;\n\n}\n\n#### 1.15 float_twice - Return bit-level equivalent of expression 2*f for\n\n目标：返回浮点uf的两倍（以unsigned的形式）\n\n方法：对于非规格化的数，uf的两倍等价于尾数左移一位，即小数字段左移移位；对于规格化的数，uf的两倍等价于阶码加一，即阶码字段加一\n\n代码：\n\n_unsigned_  float_twice(_unsigned_ uf) {\n\n  _unsigned_ f = uf;\n\n  if ((f &  0x7F800000) ==  0) { // 非规格化的\n\n f = ((f &  0x007FFFFF) <<  1) | (0x80000000  & f);\n\n }\n\n  else  if ((f &  0x7F800000) !=  0x7F800000) { // 规格化的\n\n f = f +  0x00800000;\n\n }\n\n  return f;\n\n}\n",[[1523594884588,["xzjqx@LAPTOP-GDGGKCGC",[[-1,3984,"代码：\n\n_unsigned_  float_i2f(_int_ x) {\n\n  _unsigned_ sign =  0; // 符号位\n\n  _unsigned_  exp; // 阶码\n\n  _unsigned_ frac; // 尾数\n\n  _unsigned_ shift =  0, tmp, rounding =  0;\n\n  if(x ==  0) return x; // 为0时直接返回0\n\n  if(x <  0) {\n\n x =  -x;\n\n sign =  1;\n\n } // x取绝对值，记录符号位\n\n frac = x;\n\n  while(1) {\n\n tmp = frac;\n\n shift ++;\n\n frac <<=  1;\n\n  if(tmp &  0x80000000) break;\n\n }\n\n  exp  = (159  - shift) <<  23; // 计算阶码\n\n  if((frac &  0x1ff) >  0x100) rounding =  1; // 向上舍入\n\n  else  if((frac &  0x3ff) ==  0x300) rounding =  1; // 向上舍入\n\n frac = (frac >>  9) + rounding; // 计算尾数\n\n  return (sign <<  31) +  exp  + frac;\n\n}\n\n"]],[3983,4594],[3983,3983]]],[1523594903178,["xzjqx@LAPTOP-GDGGKCGC",[[1,3984,"```\nunsigned float_i2f(int x) {\n  unsigned sign = 0;         // 符号位\n  unsigned exp;              // 阶码\n  unsigned frac;             // 尾数\n  unsigned shift = 0, tmp, rounding = 0;\n\n  if(x == 0) return x;       // 为0时直接返回0\n  if(x < 0) {\n    x = -x;\n    sign = 1;\n  }                          // x取绝对值，记录符号位\n  frac = x;\n  while(1) {\n    tmp = frac;\n    shift ++;\n    frac <<= 1;\n    if(tmp & 0x80000000) break;\n  }                          \n  exp = (159 - shift) << 23; // 计算阶码\n  if((frac & 0x1ff) > 0x100) rounding = 1;        // 向上舍入\n  else if((frac & 0x3ff) == 0x300) rounding = 1;  // 向上舍入\n  frac = (frac >> 9) + rounding; // 计算尾数\n\n  return (sign << 31) + exp + frac;\n}\n```\n\n"]],[3983,3983],[4659,4659]]],[1523594943739,["xzjqx@LAPTOP-GDGGKCGC",[[-1,4659,"\n"]],[4659,4659],[4658,4658]]],[1523594946602,["xzjqx@LAPTOP-GDGGKCGC",[[-1,4661,"## 1.15"]],[4668,4668],[4661,4661]]],[1523594949137,["xzjqx@LAPTOP-GDGGKCGC",[[-1,4754,"\n"]],[4754,4754],[4753,4753]]],[1523594951493,["xzjqx@LAPTOP-GDGGKCGC",[[-1,4821,"代码：\n\n_unsigned_  float_twice(_unsigned_ uf) {\n\n  _unsigned_ f = uf;\n\n  if ((f &  0x7F800000) ==  0) { // 非规格化的\n\n f = ((f &  0x007FFFFF) <<  1) | (0x80000000  & f);\n\n }\n\n  else  if ((f &  0x7F800000) !=  0x7F800000) { // 规格化的\n\n f = f +  0x00800000;\n\n }\n\n  return f;\n\n}\n"]],[4820,5088],[4820,4820]]],[1523594965968,["xzjqx@LAPTOP-GDGGKCGC",[[-1,4003,"i2f(int x) {\n  unsigned sign = 0;         // 符号位\n  "],[1,4054,"twice("],[-1,4063,"exp;              // 阶码\n  unsigned frac;             // 尾数"],[1,4121,"uf) {"],[-1,4133,"shi"],[-1,4137,"t"],[-1,4141,"0, tmp, rounding = 0;\n"],[1,4163,"uf;"],[-1,4168,"(x == 0) return x;       // 为0时直接返回0\n  if(x < "],[1,4214," ((f & 0x7F80000"],[-1,4217,"{\n    x "],[-1,4226," -x;\n    sign "],[-1,4242,"1;\n  }        "],[1,4256,"0) {"],[-1,4277,"x取绝对值，记录符号位\n"],[1,4289,"非规格化的\n "],[1,4291," "],[-1,4292,"rac"],[-1,4298,"x;\n  while(1) {\n    tmp = frac;\n    shift ++;\n    frac"],[1,4352,"((f & 0x007FFFFF)"],[-1,4355,"="],[-1,4358,";\n    if(tmp & "],[1,4373,") | ("],[-1,4383,") break"],[1,4390," & f)"],[-1,4395,"                          "],[-1,4425,"xp = (159 - sh"],[1,4439,"lse "],[-1,4441,"t) <<"],[-1,4447,"23; // 计算阶码\n  if"],[-1,4466,"rac"],[-1,4474,"1ff) > 0x1"],[1,4484,"7F8000"],[-1,4488,"rounding "],[1,4497,"!"],[-1,4499,"1;        // 向上舍入\n  else if((frac & "],[-1,4537,"3ff) == 0x3"],[1,4548,"7F8000"],[-1,4552,"rounding = 1;"],[1,4565,"{  "],[-1,4570,"向上舍入\n  frac = (frac >> 9) + rounding; // 计算尾数\n"],[1,4616,"规格化的\n    f = f + 0x00800000;\n  }"],[-1,4626,"(sign << 31) + exp + "],[-1,4648,"rac"]],[4654,4654],[3984,4257]]],[1523594975012,["xzjqx@LAPTOP-GDGGKCGC",[[1,4003,"i2f(int x) {\n  unsigned sign = 0;         // 符号位\n  "],[-1,4003,"twice("],[1,4018,"exp;              // 阶码\n  unsigned frac;             // 尾数"],[-1,4018,"uf) {"],[1,4035,"shi"],[1,4036,"t"],[1,4039,"0, tmp, rounding = 0;\n"],[-1,4039,"uf;"],[1,4047,"(x == 0) return x;       // 为0时直接返回0\n  if(x < "],[-1,4047," ((f & 0x7F80000"],[1,4066,"{\n    x "],[1,4067," -x;\n    sign "],[1,4069,"1;\n  }        "],[-1,4069,"0) {"],[1,4094,"x取绝对值，记录符号位\n"],[-1,4094,"非规格化的\n "],[-1,4103," "],[1,4105,"rac"],[1,4108,"x;\n  while(1) {\n    tmp = frac;\n    shift ++;\n    frac"],[-1,4108,"((f & 0x007FFFFF)"],[1,4128,"="],[1,4130,";\n    if(tmp & "],[-1,4130,") | ("],[1,4145,") break"],[-1,4145," & f)"],[1,4155,"                          "],[1,4159,"xp = (159 - sh"],[-1,4159,"lse "],[1,4165,"t) <<"],[1,4166,"23; // 计算阶码\n  if"],[1,4169,"rac"],[1,4174,"1ff) > 0x1"],[-1,4174,"7F8000"],[1,4184,"rounding "],[-1,4184,"!"],[1,4187,"1;        // 向上舍入\n  else if((frac & "],[1,4189,"3ff) == 0x3"],[-1,4189,"7F8000"],[1,4199,"rounding = 1;"],[-1,4199,"{  "],[1,4207,"向上舍入\n  frac = (frac >> 9) + rounding; // 计算尾数\n"],[-1,4207,"规格化的\n    f = f + 0x00800000;\n  }"],[1,4249,"(sign << 31) + exp + "],[1,4250,"rac"]],[3984,4257],[4654,4654]]],[1523595015234,["xzjqx@LAPTOP-GDGGKCGC",[[1,4821,"```\nunsigned float_twice(unsigned uf) {\n  unsigned f = uf;\n  if ((f & 0x7F800000) == 0) {                  // 非规格化的\n    f = ((f & 0x007FFFFF) << 1) | (0x80000000 & f);\n  }\n  else if ((f & 0x7F800000) != 0x7F800000) {    // 规格化的\n    f = f + 0x00800000;\n  }\n  return f;\n}\n```\n\n"]],[4820,4820],[5095,5095]]],[1523595123824,["xzjqx@LAPTOP-GDGGKCGC",[[1,268,"<!-- more -->"]],[268,268],[281,281]]],[1523595127960,["xzjqx@LAPTOP-GDGGKCGC",[[-1,268,"<!-- more -->"]],[281,281],[268,268]]],[1523595129426,["xzjqx@LAPTOP-GDGGKCGC",[[1,269,"\n"]],[268,268],[269,269]]],[1523595130454,["xzjqx@LAPTOP-GDGGKCGC",[[1,269,"<!-- more -->"]],[269,269],[282,282]]],[1523595313178,["xzjqx@LAPTOP-GDGGKCGC",[[1,116,"\n"]],[115,115],[116,116]]],[1523595314175,["xzjqx@LAPTOP-GDGGKCGC",[[1,116,"<!-- Date: 2016-04-23 -->"]],[116,116],[141,141]]],[1523595318946,["xzjqx@LAPTOP-GDGGKCGC",[[-1,130,"6"]],[131,131],[130,130]]],[1523595319131,["xzjqx@LAPTOP-GDGGKCGC",[[1,130,"8"]],[130,130],[131,131]]],[1523595321468,["xzjqx@LAPTOP-GDGGKCGC",[[-1,135,"2"]],[136,136],[135,135]]],[1523595321576,["xzjqx@LAPTOP-GDGGKCGC",[[1,135,"1"]],[135,135],[136,136]]],[1523595324299,["xzjqx@LAPTOP-GDGGKCGC",[[1,121," "]],[121,121],[122,122]]],[1523595328674,["xzjqx@LAPTOP-GDGGKCGC",[[1,121,"Title: "]],[121,121],[128,128]]],[1523595335905,["xzjqx@LAPTOP-GDGGKCGC",[[1,127,"深入理解计算机系统（CSAPP）实验二 Datalab"]],[127,127],[154,154]]],[1523595339421,["xzjqx@LAPTOP-GDGGKCGC",[[1,127," "]],[127,127],[128,128]]],[1523595354264,["xzjqx@LAPTOP-GDGGKCGC",[[-1,120," "]],[121,121],[120,120]]],[1523595354678,["xzjqx@LAPTOP-GDGGKCGC",[[1,120,"\n"]],[120,120],[121,121]]],[1523595363752,["xzjqx@LAPTOP-GDGGKCGC",[[-1,147," "]],[148,148],[147,147]]],[1523595363983,["xzjqx@LAPTOP-GDGGKCGC",[[1,147,"\n"]],[147,147],[148,148]]],[1523595367569,["xzjqx@LAPTOP-GDGGKCGC",[[-1,173," "]],[174,174],[173,173]]],[1523595367851,["xzjqx@LAPTOP-GDGGKCGC",[[1,173,"\n"]],[173,173],[174,174]]],[1523595369046,["xzjqx@LAPTOP-GDGGKCGC",[[-1,147,"\n"]],[148,148],[147,147]]],[1523595370524,["xzjqx@LAPTOP-GDGGKCGC",[[1,147," "]],[147,147],[148,148]]],[1523595372961,["xzjqx@LAPTOP-GDGGKCGC",[[-1,155,"  "]],[157,157],[155,155]]],[1523595373115,["xzjqx@LAPTOP-GDGGKCGC",[[1,155,"\n"]],[155,155],[156,156]]]]],["89157aa5-b0dc-48e1-9771-aceb9764314b",1523613472981,"---\nlayout: post\ndate: 2018-04-13 10:44:48\ntitle: 深入理解计算机系统（CSAPP）实验二 Datalab\ncategories: 计算机系统\ntags:\n  - C/C++\n---\n<!--\nTitle: 深入理解计算机系统（CSAPP）实验二 Datalab\nDate: 2018-04-13\n-->\n## bitAnd - x&y using only ~ and |\n\n目标：不使用&运算符计算按位与运算\n方法：运用德·摩根定律：非(P 且 Q) = (非 P) 或 (非 Q)\n```\nint bitAnd(int x, int y) {\n  return ~((~x) | (~y));\n}\n```\n<!-- more -->\n## getByte - Extract byte n from word x\n\n目标：提取一个字中的特定一个字节\n方法：将字向右移位到最低字节，再与0xff按位与得到目标字节\n\n```\nint getByte(int x, int n) {\n  return (x >> (n << 3)) & 0xff;\n}\n```\n## logicalShift - shift x to the right by n, using a logical shift\n\n目标：将x逻辑右移n位\n方法：>>操作符是算术右移，故使用>>右移后，将高n位置零即可\n\n```\nint logicalShift(int x, int n) {\n  int mask = ~(1 << 31);   // mask = 0x7fffffff\n  mask = mask >> n;\n  mask = mask << 1;\n  mask = mask + 1;         // mask高n位为0，低位为1\n  return (x >> n) & mask;\n}\n```\n## bitCount - returns count of number of 1's in word\n\n目标：计算x中有多少位1\n方法：将x分为四个字节，分别计算1的数量（共计算八次），最后将结果分为四个字节计算总和即为最终答案\n\n```\nint bitCount(int x) {\n  int result = 0;\n  int mask = 1 | (1 << 8);\n  mask = mask | (mask << 16);         // mask = 0x01010101\n  result = result + (x & mask);\n  result = result + ((x>>1) & mask);\n  result = result + ((x>>2) & mask);\n  result = result + ((x>>3) & mask);\n  result = result + ((x>>4) & mask);\n  result = result + ((x>>5) & mask);\n  result = result + ((x>>6) & mask);\n  result = result + ((x>>7) & mask);  // result的每一个字节为x在这个字节上1的数量\n  return (result & 0xff) + ((result>>8) &0xff) + ((result>>16) &0xff) + ((result>>24) &0xff);\n}\n```\n## bang - Compute !x without using !\n\n目标：不使用!运算符计算!x\n方法：将x与-x进行或运算，若x为0，最高位为0，反之最高位为1；将结果右移31位得到0xffffffff或0x00000000，加上1即为最终结果\n\n```\nint bang(int x) {\n  int tmp = ~x + 1;       // tmp = -x;\n  tmp = x | tmp;          // tmp = x | -x; 若x=0，最高位为0，反之最高位为1\n  return (tmp >> 31) + 1;\n}\n```\n## #### tmin - return minimum two's complement integer\n\n目标：求得二进制整数的最小值\n方法：1左移31位即可\n\n```\nint tmin(void) {\n  return 1<<31;\n}\n```\n## fitsBits - return 1 if x can be represented as an n-bit, two's complement integer.\n\n目标：如果x能被n位二进制补码表示，则返回1\n方法：如果x能被n位二进制表示，则x前(32-n)位都是相同的\n\n```\nint fitsBits(int x, int n) {\n  return !((x << (33 + ~n) >> (33 + ~n)) ^ x);\n}\n```\n## divpwr2 - Compute x/(2^n), for 0 <= n <= 30\n\n目标：计算 x/(2^n)\n方法：对于正数，直接右移n位即可；对于负数，需要加上偏置量bias后右移\n\n```\nint divpwr2(int x, int n) {\n  int sign = x >> 31;        // 若x为负数，sign = 0xffffffff\n  int mask = (1 << n) + ~0; // mask为0x0000ffff形式\n  int bias = sign & mask;   // 若x为负数，bias有值\n  return (x + bias) >> n;\n}\n```\n## negate - return -x\n\n目标：求相反数\n方法：补码取相反数，包含符号位一起取反再加一\n\n```\nint negate(int x) {\n  return ~x + 1;\n}\n```\n## isPositive - return 1 if x > 0, return 0 otherwise\n\n目标：判断x是否为正数\n方法：直接通过x的符号位可以分出负数，再对x两次取非可以判断是否为0\n\n```\nint isPositive(int x) {\n  return (!((x >> 31) & 1) & !!x);\n}\n```\n## isLessOrEqual - if x <= y then return 1, else return 0\n\n目标：判断是否x <= y\n方法：当x与y异号时，只要x为负数，x<=y；当x与y同号时，利用isPositive函数的方法判断y-x是否为正数或0即可\n\n```\nint isLessOrEqual(int x, int y) {\n  int signx = (x >> 31) & 1;\n  int signy = (y >> 31) & 1;\n  int sign = (signx ^ signy) & signx;               \t // 异号\n  int tmp = y + ~x + 1;\n  tmp = (!((tmp >> 31) & 1)) & (!(signx ^ signy));  // 同号\n  return (sign | tmp);\n}\n```\n## ilog2 - return floor(log base 2 of x), where x > 0\n\n目标：求floor(log2x)\n方法：通过二分法找到x中最高位1的位数，这个位数就是要求出的结果\n\n```\nint ilog2(int x) {\n  int bits=0;\n  bits = (!!(x>>16))<<4;\n  bits = bits + ((!!(x>>(bits+8)))<<3);\n  bits = bits + ((!!(x>>(bits+4)))<<2);\n  bits = bits + ((!!(x>>(bits+2)))<<1);\n  bits = bits + (!!(x>>(bits+1)));\n  bits = bits + (!!bits)+(~0)+(!(1^x));\n  return bits;\n}\n```\n## float_neg - Return bit-level equivalent of expression -f for floating point argument f\n\n目标：将浮点数uf取反\n方法：若uf不是NaN，直接将符号位取反，否则返回uf\n\n```\nunsigned float_neg(unsigned uf) {\n  unsigned result;\n  unsigned tmp;\n  result=uf ^ 0x80000000; //将符号位改反\n  tmp=uf & (0x7fffffff);\n  if(tmp > 0x7f800000)    //此时是NaN\n    result = uf;\n  return result;\n}\n```\n## float_i2f - Return bit-level equivalent of expression (float) x\n\n目标：返回整数x的对应的浮点数的二进制表示形式\n方法：这是一个求阶码与尾数的过程\n\t\t\n由于整数x一定是规格化数，故按照规格化标准转化；因为规格化的值尾数定义为M=1+f，故将x左移到最高一位1超出32位时，剩下的即为尾数；阶码是32减去上述转移的位数，故阶码字段值为127+32-shift\n\n```\nunsigned float_i2f(int x) {\n  unsigned sign = 0;         // 符号位\n  unsigned exp;              // 阶码\n  unsigned frac;             // 尾数\n  unsigned shift = 0, tmp, rounding = 0;\n\n  if(x == 0) return x;       // 为0时直接返回0\n  if(x < 0) {\n    x = -x;\n    sign = 1;\n  }                          // x取绝对值，记录符号位\n  frac = x;\n  while(1) {\n    tmp = frac;\n    shift ++;\n    frac <<= 1;\n    if(tmp & 0x80000000) break;\n  }                          \n  exp = (159 - shift) << 23; // 计算阶码\n  if((frac & 0x1ff) > 0x100) rounding = 1;        // 向上舍入\n  else if((frac & 0x3ff) == 0x300) rounding = 1;  // 向上舍入\n  frac = (frac >> 9) + rounding; // 计算尾数\n\n  return (sign << 31) + exp + frac;\n}\n```\n## float_twice - Return bit-level equivalent of expression 2*f for\n\n目标：返回浮点uf的两倍（以unsigned的形式）\n方法：对于非规格化的数，uf的两倍等价于尾数左移一位，即小数字段左移移位；对于规格化的数，uf的两倍等价于阶码加一，即阶码字段加一\n\n```\nunsigned float_twice(unsigned uf) {\n  unsigned f = uf;\n  if ((f & 0x7F800000) == 0) {                  // 非规格化的\n    f = ((f & 0x007FFFFF) << 1) | (0x80000000 & f);\n  }\n  else if ((f & 0x7F800000) != 0x7F800000) {    // 规格化的\n    f = f + 0x00800000;\n  }\n  return f;\n}\n```\n\n",[[1523613466525,["xzjqx@LAPTOP-GDGGKCGC",[[-1,4,"layout: post\n"]],[3,16],[3,3]]],[1523613470324,["xzjqx@LAPTOP-GDGGKCGC",[[-1,30,"title: 深入理解计算机系统（CSAPP）实验二 Datalab"]],[30,64],[30,30]]],[1523613470863,["xzjqx@LAPTOP-GDGGKCGC",[[-1,30,"\n"]],[30,30],[29,29]]],[1523613471639,["xzjqx@LAPTOP-GDGGKCGC",[[1,4,"\n"]],[3,3],[4,4]]],[1523613472378,["xzjqx@LAPTOP-GDGGKCGC",[[1,4,"title: 深入理解计算机系统（CSAPP）实验二 Datalab"]],[4,4],[38,38]]],[1523613489408,["xzjqx@LAPTOP-GDGGKCGC",[[-1,65,"categories: 计算机系统"]],[38,38],[65,65]]],[1523613490289,["xzjqx@LAPTOP-GDGGKCGC",[[-1,65,"\n"]],[65,65],[64,64]]],[1523613491504,["xzjqx@LAPTOP-GDGGKCGC",[[1,81,"\n"]],[80,80],[81,81]]],[1523613492263,["xzjqx@LAPTOP-GDGGKCGC",[[1,81,"categories: 计算机系统"]],[81,81],[98,98]]],[1523613504654,["xzjqx@LAPTOP-GDGGKCGC",[[-1,71,"  - "]],[75,75],[71,71]]],[1523613505035,["xzjqx@LAPTOP-GDGGKCGC",[[-1,70,"\n"]],[71,71],[70,70]]],[1523613505722,["xzjqx@LAPTOP-GDGGKCGC",[[1,70," "]],[70,70],[71,71]]],[1523613614281,["xzjqx@LAPTOP-GDGGKCGC",[[-1,11,"深入理解计算机系统（CSAPP）实验二 Datalab"],[1,38,"Hello World"],[-1,48,"8-04-13 10"],[1,58,"5-09-26 01:05"],[-1,61,":48\ntags: C/C++\ncategories: 计算机系统"]],[4,94],[48,48]]],[1523613992249,["xzjqx@LAPTOP-GDGGKCGC",[[1,11,"深入理解计算机系统（CSAPP）实验二 Datalab"],[-1,11,"Hello World"],[1,32,"8-04-13 10"],[-1,32,"5-09-26 01:05"],[1,48,":48\ntags: C/C++\ncategories: 计算机系统"]],[48,48],[4,94]]],[1523613992432,["xzjqx@LAPTOP-GDGGKCGC",[[-1,70," "]],[71,71],[70,70]]],[1523613993387,["xzjqx@LAPTOP-GDGGKCGC",[[1,70,"\n"]],[70,70],[71,71]]],[1523613996317,["xzjqx@LAPTOP-GDGGKCGC",[[-1,70,"\n"]],[71,71],[70,70]]],[1523613996869,["xzjqx@LAPTOP-GDGGKCGC",[[1,70," "]],[70,70],[71,71]]]]]]}